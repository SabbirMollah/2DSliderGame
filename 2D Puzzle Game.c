/*This is a simple 2D 4*4 Slider game
There are 16 blocks in such a puzzle.
To win you need to arrange the values from 1 to 15. (16th value should be blank __)
The position (x and y coordinates) and value of each block is stored in the structure called Blocks.

Value is stored with the help of an array called num[], and the values are created with function rand().
Checking with the function isSame() makes sure that no two values are the same.
If the puzzle is "Unsolvable" (Check WIKIPEDIA to know when a puzzle is solvable), the array is formed again from the start.

After each step (A step occurs when you press w/a/s/d button) the structure falls into a loop,
to check if the values are in order (1,2,3,4...15).
If it is in order then you win and the program asks if you want to play again, else the program waits for another step.
*/

#include<stdio.h>
#include<windows.h>
#include<stdlib.h>
#include <conio.h> 

struct Blocks{
    int x;
    int y;
    int value;
}pieces[16];            //Each piece is actually each block of the puzzle

COORD coord = {0,0};    //coord was defined globally for gotoxy() function to work properly

int isSame(int num, int *arr, int size);
void assignXY();
void gotoxy(int,int);
int win();
void display();
int gamePlay();
void swap(int currentPos, int diff);
int isSolvable(int num[]);

int main()
{
    int num[15];    //This is the array that will hold the randomly generated values
    int random;
    int step;
    char playAgain='n';
    register int i,j;
    printf("If you are trying to win this game, you probably don't have a life. Play with wasd(lower character)");

    do{                                         //This is the very first loop. This loop iterates again if the player wants to play again
        do{                                     //This 2nd loop will iterate in case the num array holds numbers  that leads to an unsolvable puzzle
            for(i=0; i<15; i++){                //Third loop fills up num array with random values
                do{                             //4th loop, continues to generate random numbers until an uniques new value is generated by rand()
                    random=rand()%15+1;
                }while( isSame(random, num,i) ); //End 4th loop
                num[i]=random;
            }   //End third loop

        }while(!isSolvable(num));   //End of 2nd loop. Iterates if the puzzle is unsolvable


        for(i=0; i<15;i++){             //Moves the values from num array to Structure Blocks (Or pieces components)
            pieces[i].value=num[i];
        }

        assignXY();                     //This function assigns x and y coordinates to Structure Blocks (Or pieces components
        display();                      //Displays The 4*4 Grid with the values
        step=gamePlay();                //This function takes the inputs and returns the number of steps.
        Sleep(1000);

        system("cls");                   //Clean screen
        printf("\n\tCongratulations. You just proved how much life less you are. Never play it again\n\n\n");
        printf("\t%d Steps? Even a child could do better.\n\n\n",step);
        printf("Play again? Y/N");
        playAgain=getch();
        system("cls");
    }while(playAgain=='Y'||playAgain=='y');     //This is the end of first loop. It iterates if player presses y or Y, so that a new game starts.

    return 0;
}



int isSame(int num, int arr[], int size){
    register int i;
    for(i=0; i<size;i++){
        if (arr[i]==num)
            return 1;
    }
    return 0;
}

void assignXY(){
    register int i;
    for (i=0; i<15; i++){
        if (i%4==0){            //i%4==0 returns true only for elements/blocks/pieces in the 1st column
            pieces[i].x=2;
        }
        else if (i%4==1){       //Returns true in col 2
            pieces[i].x=5;
        }
        else if(i%4==2){        //Returns true in col 3
            pieces[i].x=8;
        }
        else if(i%4==3){        //Returns true in col 4
            pieces[i].x=11;
        }
    }
    for (i=0; i<15; i++){
        if (i/4==0){               //Returns true in row 1
            pieces[i].y=2;
        }
        else if (i/4==1){            //Returns true in row 2
            pieces[i].y=4;
        }
        else if(i/4==2){             //Returns true in row 3
            pieces[i].y=6;
        }
        else if(i/4==3){                 //Returns true in row 4
            pieces[i].y=8;
        }
    }


    pieces[15].x=11;                    //Defines the x,y coordinates and value of the 16th piece or the blank piece
    pieces[15].y=8;
    pieces[15].value=16;
}

void gotoxy(int col, int row){                      //To understand this function you might search on WIKIPEDIA or learn Windows API
    /*HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
    COORD position = (col,row);
    SetConsoleCursorPosition(h,position);*/

    coord.X=col;
    coord.Y=row;
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),coord);
}

int win(){                  //This func checks if the values in struct Blocks are in ascending order
    register int i;
    for(i=0;i<15;i++){
        if(pieces[i].value>pieces[i+1].value)
            return 0;
    }
    return 1;               //Returns 1 if the values are in order
}

void display(){
    //system("cls");
    register int i;
    for(i=0;i<16;i++){
        gotoxy(pieces[i].x,pieces[i].y);
        if(pieces[i].value==16)     //So that value of 16th element or Blank is shown as "__" instead of "16"
            printf("__");
        else
            printf("%2d",pieces[i].value);
    }

    gotoxy(2,10);       //To have the moving cursor out of the game board. Just to remove annoyance
}

int gamePlay(){
    char ch;
    int currentPos = 15;        //This variable keeps track of the blank. Which starts as the 16th position. But 16th element's order No. is 15.
    int step=0;
    do{
        ch=getch();
        if(ch!='w'&&ch!='a'&&ch!='s'&&ch!='d')      //Ignores other keystrokes than w/a/s/d
            continue;
        else if( (currentPos/4==0)&&ch=='s' ||  (currentPos/4==3)&&ch=='w' ||  (currentPos%4==0)&&ch=='d' ||  (currentPos%4==3)&&ch=='a')
            continue;       //Ignores useless uses of w/a/s/d when blank is in a border side
        else{
                step++;
                switch (ch){
                    case 's':
                        swap(currentPos,-4);        //Swaps the value of the blank and blank's immediate bottom piece from the Structure
                        currentPos=currentPos - 4;  //currentPosition now changes  as blank's position changes
                        break;
                    case 'w':
                        swap(currentPos,4);
                        currentPos=currentPos + 4;
                        break;
                    case 'a':
                        swap(currentPos,1);
                        currentPos=currentPos + 1;
                        break;
                    case 'd':
                        swap(currentPos,-1);
                        currentPos=currentPos - 1;
                        break;
                }
                display();
                printf("\n\nSTEP: %d",step);
        }
    }while(!win());

    return step;
}

void swap(int currentPosition, int diff){       //Just like the average swap function. temp=x; x=y; y=temp;
    int value=pieces[currentPosition].value;    //Value works as the temp variable
    pieces[currentPosition].value=pieces[currentPosition+diff].value;
    pieces[currentPosition+diff].value=value;
}

int isSolvable(int num[]){      //Uses an algorithm to check if the input array holds an unsolvable puzzle
    int inversion=0;
    int i,j;

    for(i=0; i<15; i++)
    {
        for(j=i+1;j<=15;j++){
            if(num[i]>num[j])
                inversion++;
        }
    }

    if(inversion%2==0)
        return 1;
    else return 0;

}
